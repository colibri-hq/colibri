create schema authentication;
alter schema authentication owner to postgres;
grant usage on schema authentication to anon;
grant usage on schema authentication to authenticated;
grant usage on schema authentication to service_role;

alter default privileges for role postgres in schema authentication grant all on sequences to postgres;
alter default privileges for role postgres in schema authentication grant all on sequences to anon;
alter default privileges for role postgres in schema authentication grant all on sequences to authenticated;
alter default privileges for role postgres in schema authentication grant all on sequences to service_role;

alter default privileges for role postgres in schema authentication grant all on functions to postgres;
alter default privileges for role postgres in schema authentication grant all on functions to anon;
alter default privileges for role postgres in schema authentication grant all on functions to authenticated;
alter default privileges for role postgres in schema authentication grant all on functions to service_role;

alter default privileges for role postgres in schema authentication grant all on tables to postgres;
alter default privileges for role postgres in schema authentication grant all on tables to anon;
alter default privileges for role postgres in schema authentication grant all on tables to authenticated;
alter default privileges for role postgres in schema authentication grant all on tables to service_role;

-- region Access Tokens
create table authentication.access_token
(
    id         bigint                                 not null,
    user_id    bigint,
    client_id  text                                   not null,
    scopes     text[]                                 not null,
    revoked_at timestamp with time zone,
    expires_at timestamp with time zone               not null,
    created_at timestamp with time zone default now() not null,
    token      text                                   not null
);
alter table authentication.access_token
    owner to postgres;
comment on table authentication.access_token is 'OAuth Access Tokens issued by the identity provider.';
comment on column authentication.access_token.user_id is 'User ID the access token belongs to. Will be NULL for service tokens.';
comment on column authentication.access_token.token is 'The access token value.';
alter table authentication.access_token
    alter column id add generated by default as identity ( sequence name authentication.access_token_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.access_token to anon;
grant all on table authentication.access_token to authenticated;
grant all on table authentication.access_token to service_role;
grant all on sequence authentication.access_token_id_seq to anon;
grant all on sequence authentication.access_token_id_seq to authenticated;
grant all on sequence authentication.access_token_id_seq to service_role;

alter table authentication.access_token
    enable row level security;

alter table only authentication.access_token
    add constraint access_token_pkey primary key (id);
-- endregion

-- region Authenticators
create type authentication.webauthn_transport as enum ( 'usb', 'nfc', 'ble', 'smart-card', 'hybrid', 'internal', 'cable' );
alter type authentication.webauthn_transport owner to postgres;
comment on type authentication.webauthn_transport is 'A transport identifier as per the WebAuthn Level 3 specification, section 5.8.4';

create function authentication.validate_authenticator(authenticator_id character varying) returns boolean
    language plpgsql
    security definer set search_path to '' as
$$
begin
    return exists (select 1 from authentication.authenticator a where a.identifier = authenticator_id);
end;
$$;
alter function authentication.validate_authenticator(authenticator_id character varying) owner to postgres;

create table authentication.authenticator
(
    id           bigint                                       not null,
    handle       text,
    agent        text,
    type         text,
    public_key   text                                         not null,
    identifier   character varying                            not null,
    device_type  text                                         not null,
    transports   authentication.webauthn_transport[]          not null,
    counter      bigint                   default '0'::bigint not null,
    backed_up    boolean                  default false       not null,
    created_at   timestamp with time zone default now()       not null,
    updated_at   timestamp with time zone,
    last_used_at timestamp with time zone,
    user_id      bigint                                       not null
);
alter table authentication.authenticator
    owner to postgres;
comment on table authentication.authenticator is 'WebAuthn Authenticator instances';
alter table authentication.authenticator
    alter column id add generated by default as identity ( sequence name authentication.authenticator_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on function authentication.validate_authenticator(authenticator_id character varying) to anon;
grant all on function authentication.validate_authenticator(authenticator_id character varying) to authenticated;
grant all on function authentication.validate_authenticator(authenticator_id character varying) to service_role;
grant all on table authentication.authenticator to anon;
grant all on table authentication.authenticator to authenticated;
grant all on table authentication.authenticator to service_role;
grant all on sequence authentication.authenticator_id_seq to anon;
grant all on sequence authentication.authenticator_id_seq to authenticated;
grant all on sequence authentication.authenticator_id_seq to service_role;

alter table authentication.authenticator
    enable row level security;
create policy "Allow reading own authenticator details" on authentication.authenticator for select using (authentication.validate_authenticator(identifier));
create policy "Allow authenticated users to add new Webauthn devices" on authentication.authenticator for insert to authenticated with check (true);

alter table only authentication.authenticator
    add constraint authenticator_pkey primary key (id);
-- endregion

-- region Authorization Codes
create type authentication.pkce_challenge_method as enum ( 'S256' );
alter type authentication.pkce_challenge_method owner to postgres;
comment on type authentication.pkce_challenge_method is 'The PKCE challenge method used to generate the code challenge.';
create table authentication.authorization_code
(
    id               bigint                                                                                    not null,
    code             text                                                                                      not null,
    client_id        text                                                                                      not null,
    user_id          bigint                                                                                    not null,
    scopes           text[]                                                                                    not null,
    used_at          timestamp with time zone,
    revoked          boolean                              default false                                        not null,
    expires_at       timestamp with time zone                                                                  not null,
    created_at       timestamp with time zone             default now()                                        not null,
    redirect_uri     text                                                                                      not null,
    challenge        text                                                                                      not null,
    challenge_method authentication.pkce_challenge_method default 'S256'::authentication.pkce_challenge_method not null
);
alter table authentication.authorization_code
    owner to postgres;
comment on table authentication.authorization_code is 'OAuth authorization codes that can be exchanged for an access token.';
comment on column authentication.authorization_code.code is 'Actual authorization code value.';
comment on column authentication.authorization_code.scopes is 'Effective OAuth scopes granted by the user to the client which generated this authorization code.';
comment on column authentication.authorization_code.used_at is 'Timestamp when this authorization code has been used by a client to issue an access token, and thus cannot be used anymore.';
comment on column authentication.authorization_code.revoked is 'Whether this authorization code has been revoked and cannot be used anymore.';
comment on column authentication.authorization_code.redirect_uri is 'Redirect URI where the response will be sent.';
comment on column authentication.authorization_code.challenge is 'The PKCE code challenge associated with the authorization code.';
alter table authentication.authorization_code
    alter column id add generated by default as identity ( sequence name authentication.authorization_code_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.authorization_code to anon;
grant all on table authentication.authorization_code to authenticated;
grant all on table authentication.authorization_code to service_role;
grant all on sequence authentication.authorization_code_id_seq to anon;
grant all on sequence authentication.authorization_code_id_seq to authenticated;
grant all on sequence authentication.authorization_code_id_seq to service_role;

alter table authentication.authorization_code
    enable row level security;

alter table only authentication.authorization_code
    add constraint authorization_code_pkey primary key (id);
-- endregion

-- region Authorization Requests
create table authentication.authorization_request
(
    id                    bigint                                             not null,
    identifier            uuid                     default gen_random_uuid() not null,
    client_id             text                                               not null,
    response_type         text                                               not null,
    redirect_uri          text                                               not null,
    scopes                text[],
    state                 text,
    code_challenge        text                                               not null,
    code_challenge_method text                                               not null,
    created_at            timestamp with time zone default now()             not null,
    expires_at            timestamp with time zone                           not null,
    used_at               timestamp with time zone
);
alter table authentication.authorization_request
    owner to postgres;
comment on table authentication.authorization_request is 'Authorization requests as created via the Pushed Authorization Request defined in RFC 9126.';
comment on column authentication.authorization_request.expires_at is 'TImestamp the authorization request expires.';
comment on column authentication.authorization_request.used_at is 'Timestamp the authorization request has been used.';
alter table authentication.authorization_request
    alter column id add generated by default as identity ( sequence name authentication.authorization_request_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.authorization_request to anon;
grant all on table authentication.authorization_request to authenticated;
grant all on table authentication.authorization_request to service_role;
grant all on sequence authentication.authorization_request_id_seq to anon;
grant all on sequence authentication.authorization_request_id_seq to authenticated;
grant all on sequence authentication.authorization_request_id_seq to service_role;

alter table authentication.authorization_request
    enable row level security;

alter table only authentication.authorization_request
    add constraint authorization_request_pkey primary key (id);
-- endregion

-- region Challenges
create function authentication.validate_challenge(value character varying) returns boolean
    language plpgsql
    security definer set search_path to '' as
$$
begin
    return exists (select 1 from authentication.challenge c where challenge = value);
end;
$$;
alter function authentication.validate_challenge(value character varying) owner to postgres;
grant all on function authentication.validate_challenge(value character varying) to anon;
grant all on function authentication.validate_challenge(value character varying) to authenticated;
grant all on function authentication.validate_challenge(value character varying) to service_role;

create table authentication.challenge
(
    id                 bigint                                 not null,
    challenge          text                                   not null,
    session_identifier text                                   not null,
    created_at         timestamp with time zone default now() not null,
    expires_at         timestamp with time zone               not null
);
alter table authentication.challenge
    owner to postgres;
comment on table authentication.challenge is 'WebAuthn Authenticator Challenges';
alter table authentication.challenge
    alter column id add generated by default as identity ( sequence name authentication.challenge_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.challenge to anon;
grant all on table authentication.challenge to authenticated;
grant all on table authentication.challenge to service_role;
grant all on sequence authentication.challenge_id_seq to anon;
grant all on sequence authentication.challenge_id_seq to authenticated;
grant all on sequence authentication.challenge_id_seq to service_role;

alter table authentication.challenge
    enable row level security;
create policy "Allow reading own challenges" on authentication.challenge for select using (authentication.validate_challenge((challenge)::character varying));
create policy "Allow creating challenges for all users" on authentication.challenge for insert with check (true);

alter table only authentication.challenge
    add constraint challenge_pkey primary key (id);
-- endregion

-- region Clients
create table authentication.client
(
    id            text                                   not null,
    redirect_uris text[],
    secret        text,
    name          text,
    description   text,
    user_id       bigint,
    created_at    timestamp with time zone default now() not null,
    updated_at    timestamp with time zone,
    personal      boolean                  default false not null,
    revoked       boolean                  default false not null,
    active        boolean                  default true  not null,
    constraint client_id_check check ((id ~ '^[a-zA-Z][a-zA-Z0-9:-]*[a-zA-Z0-9]$'::text))
);
alter table authentication.client
    owner to postgres;
comment on table authentication.client is 'OAuth clients';
comment on column authentication.client.id is 'Alphanumeric ID of the client.';
comment on column authentication.client.redirect_uris is 'OAuth Redirect URIs registered for this client. A server-side client must not have any redirect URIs, otherwise it cannot be used with the client_credentials grant.';
comment on column authentication.client.secret is 'OAuth client secret for this client. Must be NULL unless intended for server-side clients (which may only use the client_credentials grant type).';
comment on column authentication.client.user_id is 'Owner of this client. Must be NULL for system clients, which cannot be modified in the user interface and will skip the permission dialogs.';
comment on column authentication.client.personal is 'Whether this client is only available to its owner. Must be FALSE for system clients.';
comment on column authentication.client.revoked is 'Whether the client has been revoked. Any token or authorization code issued by the client will also be regarded as revoked.';
comment on column authentication.client.active is 'Whether the client is in active use. Inactive clients will not be able to issue access tokens.';

grant all on table authentication.client to anon;
grant all on table authentication.client to authenticated;
grant all on table authentication.client to service_role;

alter table authentication.client
    enable row level security;

alter table only authentication.client
    add constraint client_pkey primary key (id);
alter table only authentication.client
    add constraint client_redirect_uris_key unique (redirect_uris);

create table authentication.client_scope
(
    client_id text not null,
    scope_id  text not null
);
alter table authentication.client_scope
    owner to postgres;
comment on table authentication.client_scope is 'OAuth scopes available to specific clients.';

grant all on table authentication.client_scope to anon;
grant all on table authentication.client_scope to authenticated;
grant all on table authentication.client_scope to service_role;

alter table authentication.client_scope
    enable row level security;

alter table only authentication.client_scope
    add constraint client_scopes_pkey primary key (client_id, scope_id);
-- endregion

-- region Device Challenges
create table authentication.device_challenge
(
    id           bigint                                 not null,
    user_code    text                                   not null,
    device_code  text                                   not null,
    client_id    text                                   not null,
    approved     boolean,
    last_poll_at timestamp with time zone,
    expires_at   timestamp with time zone               not null,
    created_at   timestamp with time zone default now() not null,
    scopes       text[],
    used_at      timestamp with time zone,
    constraint device_challenge_user_code_check check ((length(user_code) <= 8))
);
alter table authentication.device_challenge
    owner to postgres;
comment on table authentication.device_challenge is 'OAuth Device Grant Challenges';
comment on column authentication.device_challenge.user_code is 'Verification code the user has to enter on the device screen; should be short (usually 6-8 numbers and/or letters). Maximum of 8 characters for usability reasons.';
comment on column authentication.device_challenge.device_code is 'Verification code for this challenge as generated by the authorization server.';
comment on column authentication.device_challenge.client_id is 'ID of the client that created the challenge.';
comment on column authentication.device_challenge.approved is 'Whether the challenge has been approved by the user (true), denied (false), or is still pending (NULL).';
comment on column authentication.device_challenge.last_poll_at is 'Last time the client has polled for the current challenge status, used to prevent abuse. Will be NULL if the client has not polled yet.';
comment on column authentication.device_challenge.expires_at is 'Expiration time of this device challenge.';
comment on column authentication.device_challenge.created_at is 'Creation time of this device challenge.';
comment on column authentication.device_challenge.scopes is 'Optional set of scopes requested by the client for this specific challenge. Only used if a subset of the available client scopes is provided.';
comment on column authentication.device_challenge.used_at is 'Timestamp when the device code has been used to issue an access token, and thus cannot be used anymore. ';
alter table authentication.device_challenge
    alter column id add generated by default as identity ( sequence name authentication.device_challenge_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.device_challenge to anon;
grant all on table authentication.device_challenge to authenticated;
grant all on table authentication.device_challenge to service_role;
grant all on sequence authentication.device_challenge_id_seq to anon;
grant all on sequence authentication.device_challenge_id_seq to authenticated;
grant all on sequence authentication.device_challenge_id_seq to service_role;

alter table authentication.device_challenge
    enable row level security;

alter table only authentication.device_challenge
    add constraint device_challenge_pkey primary key (id);
-- endregion

-- region Passcodes
create table authentication.passcode
(
    id         bigint                                 not null,
    created_at timestamp with time zone default now() not null,
    expires_at timestamp with time zone               not null,
    code       character varying                      not null,
    user_id    bigint                                 not null
);
alter table authentication.passcode
    owner to postgres;
comment on table authentication.passcode is 'One-time authentication passcodes';
alter table authentication.passcode
    alter column id add generated by default as identity ( sequence name authentication.passcode_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.passcode to anon;
grant all on table authentication.passcode to authenticated;
grant all on table authentication.passcode to service_role;
grant all on sequence authentication.passcode_id_seq to anon;
grant all on sequence authentication.passcode_id_seq to authenticated;
grant all on sequence authentication.passcode_id_seq to service_role;

alter table authentication.passcode
    enable row level security;

alter table only authentication.passcode
    add constraint passcode_pkey primary key (id);
alter table only authentication.passcode
    add constraint passcode_user_id_key unique (user_id);
-- endregion

-- region Refresh Tokens
create table authentication.refresh_token
(
    id         bigint                                 not null,
    token      text                                   not null,
    user_id    bigint,
    client_id  text                                   not null,
    scopes     text[]                                 not null,
    revoked_at timestamp with time zone,
    expires_at timestamp with time zone               not null,
    created_at timestamp with time zone default now() not null
);
alter table authentication.refresh_token
    owner to postgres;
comment on table authentication.refresh_token is 'OAuth Refresh Tokens issued by the identity provider.';
comment on column authentication.refresh_token.user_id is 'User ID the refresh token belongs to. Will be NULL for service tokens.';
alter table authentication.refresh_token
    alter column id add generated by default as identity ( sequence name authentication.refresh_token_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.refresh_token to anon;
grant all on table authentication.refresh_token to authenticated;
grant all on table authentication.refresh_token to service_role;
grant all on sequence authentication.refresh_token_id_seq to anon;
grant all on sequence authentication.refresh_token_id_seq to authenticated;
grant all on sequence authentication.refresh_token_id_seq to service_role;

alter table authentication.refresh_token
    enable row level security;

alter table only authentication.refresh_token
    add constraint refresh_token_pkey primary key (id);
alter table only authentication.refresh_token
    add constraint refresh_token_token_key unique (token);
-- endregion

-- region Scopes
create table authentication.scope
(
    id          text                                   not null,
    description text,
    created_at  timestamp with time zone default now() not null,
    server      boolean                  default false not null,
    constraint scope_id_check check ((id ~ '^[a-zA-Z][a-zA-Z0-9:_-]*[a-zA-Z0-9]$'::text))
);
alter table authentication.scope
    owner to postgres;
comment on table authentication.scope is 'OAuth scopes';
comment on column authentication.scope.id is 'Name of the scope. Must';
comment on column authentication.scope.server is 'Whether this scope is only available to server-side client integrations using the client_credentials grant.';

grant all on table authentication.scope to anon;
grant all on table authentication.scope to authenticated;
grant all on table authentication.scope to service_role;

alter table authentication.scope
    enable row level security;

alter table only authentication.scope
    add constraint scope_pkey primary key (id);
-- endregion

-- region Users
create type authentication.color_scheme as enum ( 'system', 'light', 'dark' );
alter type authentication.color_scheme owner to postgres;
comment on type authentication.color_scheme is 'The color scheme for the application, used to control light/dark mode.';

create type authentication.user_role as enum ( 'admin', 'adult', 'child', 'guest' );
alter type authentication.user_role owner to postgres;
comment on type authentication.user_role is 'An authorization role for a user.';

create table authentication."user"
(
    id           bigint                                                                not null,
    created_at   timestamp with time zone    default now()                             not null,
    updated_at   timestamp with time zone,
    name         character varying,
    email        character varying                                                     not null,
    verified     boolean                     default false                             not null,
    birthdate    date,
    role         authentication.user_role    default 'adult'::authentication.user_role not null,
    color_scheme authentication.color_scheme default 'system'::authentication.color_scheme
);
alter table authentication."user"
    owner to postgres;
comment on table authentication."user" is 'Application users';
comment on column authentication."user".birthdate is 'The birthdate of a user. This is used to automatically apply age restrictions, if the user has the child role.';
comment on column authentication."user".role is 'The authorization role of a user.';
comment on column authentication."user".color_scheme is 'Preferred color scheme to display the application in.';
alter table authentication."user"
    alter column id add generated by default as identity ( sequence name authentication.user_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication."user" to anon;
grant all on table authentication."user" to authenticated;
grant all on table authentication."user" to service_role;
grant all on sequence authentication.user_id_seq to anon;
grant all on sequence authentication.user_id_seq to authenticated;
grant all on sequence authentication.user_id_seq to service_role;

alter table authentication."user"
    enable row level security;

alter table only authentication."user"
    add constraint user_email_key unique (email);
alter table only authentication."user"
    add constraint user_pkey primary key (id);
-- endregion

-- region User Consent
create table authentication.user_consent
(
    user_id    bigint                                 not null,
    client_id  text                                   not null,
    granted_at timestamp with time zone default now() not null,
    expires_at timestamp with time zone               not null,
    revoked_at timestamp with time zone,
    scopes     text[]                                 not null
);
alter table authentication.user_consent
    owner to postgres;
comment on table authentication.user_consent is 'User consent granted to OAuth clients.';
comment on column authentication.user_consent.granted_at is 'Timestamp the user has granted consent to the client.';
comment on column authentication.user_consent.expires_at is 'Timestamp of consent expiration. To avoid indefinitely granting consent to a client, users have to reconfirm their choices after a given amount of time.';
comment on column authentication.user_consent.revoked_at is 'Timestamp the user revoked their consent for the client. Effectively the same as having never given consent at all. If NULL, the user did not revoke their consent yet.';
comment on column authentication.user_consent.scopes is 'Scopes the user has granted the client to use at the time of consent.';
alter table authentication.user_consent
    alter column user_id add generated by default as identity ( sequence name authentication.user_consent_user_id_seq start with 1 increment by 1 no minvalue no maxvalue cache 1 );

grant all on table authentication.user_consent to anon;
grant all on table authentication.user_consent to authenticated;
grant all on table authentication.user_consent to service_role;
grant all on sequence authentication.user_consent_user_id_seq to anon;
grant all on sequence authentication.user_consent_user_id_seq to authenticated;
grant all on sequence authentication.user_consent_user_id_seq to service_role;

alter table authentication.user_consent
    enable row level security;

alter table only authentication.user_consent
    add constraint user_consent_pkey primary key (user_id, client_id);
-- endregion

alter table only authentication.access_token
    add constraint access_token_client_id_fkey foreign key (client_id) references authentication.client (id) on update cascade on delete cascade;
alter table only authentication.access_token
    add constraint access_token_user_id_fkey foreign key (user_id) references authentication."user" (id) on update cascade on delete cascade;
alter table only authentication.authenticator
    add constraint authentication_authenticator_user_id_fkey foreign key (user_id) references authentication."user" (id) on update cascade on delete cascade;
alter table only authentication.passcode
    add constraint authentication_passcode_user_id_fkey foreign key (user_id) references authentication."user" (id) on update cascade on delete cascade;
alter table only authentication.authorization_code
    add constraint authorization_code_client_id_fkey foreign key (client_id) references authentication.client (id) on update cascade on delete cascade;
alter table only authentication.authorization_code
    add constraint authorization_code_user_id_fkey foreign key (user_id) references authentication."user" (id) on update cascade on delete cascade;
alter table only authentication.authorization_request
    add constraint authorization_request_client_id_fkey foreign key (client_id) references authentication.client (id) on update cascade on delete cascade;
alter table only authentication.client_scope
    add constraint client_scopes_client_id_fkey foreign key (client_id) references authentication.client (id) on update cascade on delete cascade;
alter table only authentication.client_scope
    add constraint client_scopes_scope_id_fkey foreign key (scope_id) references authentication.scope (id) on update cascade on delete cascade;
alter table only authentication.client
    add constraint client_user_id_fkey foreign key (user_id) references authentication."user" (id) on update cascade on delete cascade;
alter table only authentication.device_challenge
    add constraint device_challenge_client_id_fkey foreign key (client_id) references authentication.client (id) on update cascade on delete cascade;
alter table only authentication.refresh_token
    add constraint refresh_token_client_id_fkey foreign key (client_id) references authentication.client (id) on update cascade on delete cascade;
alter table only authentication.refresh_token
    add constraint refresh_token_user_id_fkey foreign key (user_id) references authentication."user" (id) on update cascade on delete cascade;
alter table only authentication.user_consent
    add constraint user_consent_client_id_fkey foreign key (client_id) references authentication.client (id) on update cascade on delete cascade;
alter table only authentication.user_consent
    add constraint user_consent_user_id_fkey foreign key (user_id) references authentication."user" (id) on update cascade on delete cascade;

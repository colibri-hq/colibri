# Notification System Overhaul Plan

## Current State (MVP Implementation)

The current notification system is intentionally simple for the MVP:
- Single notification table with basic fields
- Simple preferences table per user
- SSE-based real-time delivery
- In-memory event handling

## Issues with Current Design

1. **Scalability**: Single table will grow indefinitely
2. **Delivery Guarantees**: No retry mechanism for failed deliveries
3. **Batching**: No aggregation of similar notifications (e.g., "5 people reacted to your comment")
4. **Templates**: Hardcoded notification text, no i18n support
5. **Channels**: Only in-app notifications, no email/push support
6. **Preferences**: Simplistic on/off toggles, no time-based or frequency controls
7. **Performance**: Full table scans for unread counts

## Proposed Architecture

### 1. Notification Events (Write Path)

```
Event Producer → Message Queue → Event Processor → Storage + Delivery
```

**Components:**
- **Event Table**: Append-only log of notification-triggering events
- **Message Queue**: Postgres NOTIFY/LISTEN or external queue (Redis, etc.)
- **Event Processor**: Aggregates events, applies rules, generates notifications
- **Delivery Adapters**: In-app, email, push, webhooks

### 2. Database Schema Redesign

```sql
-- Raw notification events (append-only log)
CREATE TABLE notification_event (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_type text NOT NULL,  -- 'comment.reply', 'comment.reaction', 'comment.mention'
    actor_id bigint NOT NULL,  -- Who triggered the event
    target_id bigint NOT NULL, -- Who should be notified
    entity_type text NOT NULL, -- 'comment', 'work', 'collection'
    entity_id bigint NOT NULL,
    metadata jsonb DEFAULT '{}', -- Event-specific data
    created_at timestamptz DEFAULT now()
);

-- Aggregated/processed notifications
CREATE TABLE notification (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id bigint NOT NULL,
    notification_type text NOT NULL,
    template_key text NOT NULL,  -- For i18n lookups
    template_data jsonb NOT NULL, -- Variables for template rendering
    link text,
    priority int DEFAULT 0,
    -- Read state
    read_at timestamptz,
    -- Delivery tracking
    delivered_at timestamptz,
    delivery_channel text, -- 'in_app', 'email', 'push'
    -- Lifecycle
    created_at timestamptz DEFAULT now(),
    expires_at timestamptz, -- Auto-cleanup
    -- Aggregation
    event_count int DEFAULT 1,
    first_event_at timestamptz,
    last_event_at timestamptz
);

-- Granular notification preferences
CREATE TABLE notification_preference (
    user_id bigint NOT NULL,
    notification_type text NOT NULL,
    channel text NOT NULL, -- 'in_app', 'email', 'push'
    enabled boolean DEFAULT true,
    -- Fine-grained controls
    digest_frequency text, -- 'immediate', 'hourly', 'daily', 'weekly'
    quiet_hours_start time,
    quiet_hours_end time,
    -- Thresholds
    min_aggregation_count int DEFAULT 1, -- Wait for N events before notifying
    aggregation_window_minutes int DEFAULT 5,
    PRIMARY KEY (user_id, notification_type, channel)
);

-- Notification templates (i18n)
CREATE TABLE notification_template (
    key text PRIMARY KEY,
    locale text NOT NULL DEFAULT 'en',
    title_template text NOT NULL,
    body_template text NOT NULL,
    -- Channel-specific templates
    email_subject_template text,
    email_body_template text,
    push_title_template text,
    push_body_template text
);
```

### 3. Event Processing Pipeline

1. **Ingestion**: Events written to `notification_event` table
2. **Aggregation**:
   - Group events by (target_id, event_type, entity_id) within time window
   - Count similar events (e.g., 5 reactions on same comment)
3. **Filtering**:
   - Check user preferences
   - Check quiet hours
   - Check if user is online (skip email if reading in-app)
4. **Template Rendering**:
   - Look up template by key and locale
   - Substitute variables
5. **Delivery**:
   - Route to appropriate channel adapter
   - Track delivery status
   - Retry on failure

### 4. Delivery Channels

**In-App (SSE)**:
- Keep existing SSE infrastructure
- Add connection tracking
- Send immediately for online users

**Email**:
- Queue for digest processing
- Render HTML templates
- Track opens/clicks

**Push Notifications**:
- Web Push API integration
- Native app support via FCM/APNS
- Subscription management

### 5. Performance Optimizations

**Indexes**:
```sql
-- For unread counts (covering index)
CREATE INDEX idx_notification_user_unread_count
ON notification (user_id)
WHERE read_at IS NULL;

-- For fetching recent notifications
CREATE INDEX idx_notification_user_recent
ON notification (user_id, created_at DESC);

-- For cleanup jobs
CREATE INDEX idx_notification_expires
ON notification (expires_at)
WHERE expires_at IS NOT NULL;
```

**Caching**:
- Cache unread counts in Redis
- Invalidate on read/new notification
- TTL-based expiration

**Partitioning**:
- Consider time-based partitioning for notification_event
- Archive old notifications

### 6. Implementation Phases

#### Phase 1: Core Infrastructure (1-2 weeks)
- [ ] Redesign database schema
- [ ] Implement event producer interface
- [ ] Create notification service abstraction
- [ ] Migrate existing notifications

#### Phase 2: Aggregation & Templates (1 week)
- [ ] Implement aggregation logic
- [ ] Create template system with i18n
- [ ] Add template management UI

#### Phase 3: Email Delivery (1 week)
- [ ] Integrate email provider
- [ ] Create digest scheduling
- [ ] Design email templates

#### Phase 4: Push Notifications (1 week)
- [ ] Implement Web Push
- [ ] Add subscription management
- [ ] Handle mobile app integration

#### Phase 5: Advanced Preferences (1 week)
- [ ] Quiet hours implementation
- [ ] Per-notification-type preferences
- [ ] Channel preferences

### 7. Migration Strategy

1. **Dual-write**: Write to both old and new tables during transition
2. **Background migration**: Migrate historical data in batches
3. **Feature flag**: Gradually roll out new system
4. **Cleanup**: Remove old tables after full migration

---

## Timeline

This overhaul should be planned for post-MVP, when:
- User base has grown enough to warrant optimization
- Email notification requirements are confirmed
- Push notification requirements are defined
- Performance bottlenecks are observed

**Estimated effort**: 4-6 weeks for full implementation

**Priority**: Medium - Current MVP implementation will work for initial launch
